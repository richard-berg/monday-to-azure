import json
import logging

import azure.durable_functions as durable_func
import azure.functions as func
from azure.identity.aio import DefaultAzureCredential
from azure.keyvault.secrets.aio import SecretClient

from monday_fns import MondayUser, get_monday_roster
from msgraph_fns import sync_all_group_membership, upsert_aad_users


AZURE_VAULT_URL = "https://cantorivault.vault.azure.net/"
MONDAY_SECRET_NAME = "monday-api-key"

AZURE_STORAGE_URL = "https://cantoriaadsync.blob.core.windows.net"
AZURE_STORAGE_CONTAINER = "data-from-monday"
AZURE_STORAGE_BLOB = "roster"

dfApp = durable_func.DFApp(http_auth_level=func.AuthLevel.ANONYMOUS)


@dfApp.route(route="monday-webhook")
@dfApp.durable_client_input(client_name="client")
async def monday_webhook(req: func.HttpRequest, client) -> func.HttpResponse:
    challenge, event = _parse_webhook_body(req)
    instance_id = await client.start_new(monday_sync_orchestrator._function._name, client_input=event)
    response = client.create_check_status_response(req, instance_id)
    return _insert_challenge(challenge, response)


def _parse_webhook_body(request: func.HttpRequest) -> tuple[str, dict]:
    try:
        request_body = request.get_body()
        request_json = json.loads(request_body[:1000])  # prevent DOS
        challenge = request_json["challenge"]
        event = request_json["event"]
        return challenge, event
    except Exception:
        return "", {}


def _insert_challenge(challenge: str, response: func.HttpResponse) -> func.HttpResponse:
    """Enrich the HttpResponse generated by Durable Function so that it includes Monday.com's challenge string
    See: https://support.monday.com/hc/en-us/articles/360003540679-Webhook-Integration-?_ga=2.108678859.838519620.1692582277-1931607118.1665512780
    """
    response_body = response.get_body()
    response_json = json.loads(response_body)
    response_json["challenge"] = challenge
    return func.HttpResponse(
        body=json.dumps(response_json),
        charset=response.charset,
        headers=response.headers,
        mimetype=response.mimetype,
        status_code=response.status_code,
    )


@dfApp.orchestration_trigger(context_name="context")
def monday_sync_orchestrator(context: durable_func.DurableOrchestrationContext):
    retry_options = durable_func.RetryOptions(5000, 3)
    webhook_event = context.get_input()
    roster = yield context.call_activity_with_retry(pull_from_monday, retry_options, webhook_event)
    # push_result = yield context.call_activity_with_retry(push_to_aad, retry_options, roster)
    push_result = yield context.call_activity(push_to_aad, roster)

    return push_result


@dfApp.activity_trigger(input_name="webhookEvent")
async def pull_from_monday(webhookEvent) -> list[MondayUser]:
    async with DefaultAzureCredential() as credential:
        secret_client = SecretClient(vault_url=AZURE_VAULT_URL, credential=credential)
        monday_api_key = await secret_client.get_secret(MONDAY_SECRET_NAME)
        if not monday_api_key.value:
            raise RuntimeError("Monday API key not found in Vault")
        roster = await get_monday_roster(monday_api_key.value, webhookEvent)
        logging.info(f"Got {len(roster)} users from Monday.com")
        return roster


@dfApp.activity_trigger(input_name="roster")
async def push_to_aad(roster: list[MondayUser]) -> list:
    email_to_user_id = await upsert_aad_users(roster)
    await sync_all_group_membership(roster, email_to_user_id)
    return []  # Durable Function runtime requires a JSON-parsable return value
